import _extends from 'babel-runtime/helpers/extends';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import * as React from 'react';
import PopperJS from 'popper.js';

import { ManagerContext } from './Manager';
import { safeInvoke, unwrapArray } from './utils';

var initialStyle = {
  position: 'absolute',
  top: 0,
  left: 0,
  opacity: 0,
  pointerEvents: 'none'
};

var initialArrowStyle = {};

export var InnerPopper = function (_React$Component) {
  _inherits(InnerPopper, _React$Component);

  function InnerPopper() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, InnerPopper);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = InnerPopper.__proto__ || _Object$getPrototypeOf(InnerPopper)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      popperNode: undefined,
      arrowNode: undefined,
      popperInstance: undefined,
      data: undefined
    }, _this.setPopperNode = function (popperNode) {
      safeInvoke(_this.props.innerRef, popperNode);
      _this.setState({ popperNode: popperNode });
    }, _this.setArrowNode = function (arrowNode) {
      return _this.setState({ arrowNode: arrowNode });
    }, _this.updateStateModifier = {
      enabled: true,
      order: 900,
      fn: function fn(data) {
        _this.setState({ data: data });
        return data;
      }
    }, _this.getOptions = function () {
      return {
        placement: _this.props.placement,
        eventsEnabled: _this.props.eventsEnabled,
        positionFixed: _this.props.positionFixed,
        modifiers: _extends({}, _this.props.modifiers, {
          arrow: {
            enabled: !!_this.state.arrowNode,
            element: _this.state.arrowNode
          },
          applyStyle: { enabled: false },
          updateStateModifier: _this.updateStateModifier
        })
      };
    }, _this.getPopperStyle = function () {
      return !_this.state.popperNode || !_this.state.data ? initialStyle : _extends({
        position: _this.state.data.offsets.popper.position
      }, _this.state.data.styles);
    }, _this.getPopperPlacement = function () {
      return !_this.state.data ? undefined : _this.state.data.placement;
    }, _this.getArrowStyle = function () {
      return !_this.state.arrowNode || !_this.state.data ? initialArrowStyle : _this.state.data.arrowStyles;
    }, _this.getOutOfBoundariesState = function () {
      return _this.state.data ? _this.state.data.hide : undefined;
    }, _this.initPopperInstance = function () {
      var referenceElement = _this.props.referenceElement;
      var _this$state = _this.state,
          popperNode = _this$state.popperNode,
          popperInstance = _this$state.popperInstance;

      if (referenceElement && popperNode && !popperInstance) {
        var _popperInstance = new PopperJS(referenceElement, popperNode, _this.getOptions());
        _this.setState({ popperInstance: _popperInstance });
        return true;
      }
      return false;
    }, _this.destroyPopperInstance = function (callback) {
      if (_this.state.popperInstance) {
        _this.state.popperInstance.destroy();
      }
      _this.setState({ popperInstance: undefined }, callback);
    }, _this.updatePopperInstance = function () {
      if (_this.state.popperInstance) {
        _this.destroyPopperInstance(function () {
          return _this.initPopperInstance();
        });
      }
    }, _this.scheduleUpdate = function () {
      if (_this.state.popperInstance) {
        _this.state.popperInstance.scheduleUpdate();
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(InnerPopper, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      // If needed, initialize the Popper.js instance
      // it will return `true` if it initialized a new instance, or `false` otherwise
      // if it returns `false`, we make sure Popper props haven't changed, and update
      // the Popper.js instance if needed
      if (!this.initPopperInstance()) {
        // If the Popper.js options have changed, update the instance (destroy + create)
        if (this.props.placement !== prevProps.placement || this.props.eventsEnabled !== prevProps.eventsEnabled || this.state.arrowNode !== prevState.arrowNode || this.state.popperNode !== prevState.popperNode || this.props.referenceElement !== prevProps.referenceElement || this.props.positionFixed !== prevProps.positionFixed) {
          this.updatePopperInstance();
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.state.popperInstance) {
        this.state.popperInstance.destroy();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return unwrapArray(this.props.children)({
        ref: this.setPopperNode,
        style: this.getPopperStyle(),
        placement: this.getPopperPlacement(),
        outOfBoundaries: this.getOutOfBoundariesState(),
        scheduleUpdate: this.scheduleUpdate,
        arrowProps: {
          ref: this.setArrowNode,
          style: this.getArrowStyle()
        }
      });
    }
  }]);

  return InnerPopper;
}(React.Component);

InnerPopper.defaultProps = {
  placement: 'bottom',
  eventsEnabled: true,
  referenceElement: undefined,
  positionFixed: false
};
var placements = PopperJS.placements;
export { placements };

export default function Popper(props) {
  return React.createElement(
    ManagerContext.Consumer,
    null,
    function (_ref2) {
      var referenceNode = _ref2.referenceNode;
      return React.createElement(InnerPopper, _extends({ referenceElement: referenceNode }, props));
    }
  );
}